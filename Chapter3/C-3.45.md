### 序列S包含n-1个唯一的整数，整数范围为[0, n-1]，即此范围内有一个数不属于S。设计一个O(n)-时间算法找出此数。除了S本身所占的内存外，仅允许你使用O(1)的额外空间。

要解决序列 \(S\) 中缺失一个唯一整数（范围 \([0, n-1]\)）的问题，并满足 \(O(n)\) 时间复杂度和 \(O(1)\) 额外空间（除序列 \(S\) 本身所占内存外）的要求，可以采用位运算中的异或（XOR）操作。异或操作具有以下性质：任何数与自身异或结果为 0，任何数与 0 异或结果为自身。因此，通过计算从 0 到 \(n-1\) 所有整数的异或值，再与序列 \(S\) 中所有元素的异或值进行异或操作，最终结果即为缺失的数。

### 算法描述
1. **初始化变量**：设变量 `missing` 为 0，用于存储异或结果。
2. **计算完整范围的异或值**：遍历整数 \(i\) 从 0 到 \(n-1\)（包括两端），对每个 \(i\) 执行 `missing = missing XOR i`。此时，`missing` 存储了从 0 到 \(n-1\) 所有整数的异或值。
3. **计算序列 \(S\) 的异或值**：遍历序列 \(S\) 中的每个元素 \(x\)，对每个 \(x\) 执行 `missing = missing XOR x`。由于 \(S\) 包含除缺失数外的所有整数，此操作会将完整范围中存在的数（除缺失数外）异或两次，从而抵消为 0，而缺失数只异或一次（来自步骤 2），因此最终 `missing` 的值即为缺失的数。
4. **返回结果**：返回 `missing`。

### 算法分析
- **时间复杂度**：算法包含两个独立的循环：第一个循环遍历 \(n\) 个整数（0 到 \(n-1\)），第二个循环遍历 \(n-1\) 个元素（序列 \(S\)）。每个循环的时间复杂度为 \(O(n)\)，因此总时间复杂度为 \(O(n)\)。
- **空间复杂度**：除输入序列 \(S\) 外，仅使用固定数量的额外变量（如 `missing` 和循环计数器），额外空间复杂度为 \(O(1)\)。

### 算法优势
- **避免溢出问题**：相比于使用求和（即计算完整范围的和减去序列 \(S\) 的和）的方法，异或操作不受整数溢出影响，尤其当 \(n\) 较大时更鲁棒。
- **高效且简单**：异或操作计算速度快，且代码实现简洁。

### 代码示例
```python
def find_missing_number(S, n):
    missing = 0
    # 将missing与完整范围[0, n-1]的所有数字异或
    for i in range(n):
        missing ^= i
    
    # 将missing与序列S中的所有元素异或
    for num in S:
        missing ^= num
    
    return missing

# 示例测试
if __name__ == "__main__":
    n = 5
    S = [0, 1, 3, 4]  # 缺失数字2
    print(find_missing_number(S, n))  # 输出: 2
    
    n = 3
    S = [1, 2]         # 缺失数字0
    print(find_missing_number(S, n))  # 输出: 0
    
    n = 1
    S = []             # 缺失数字0
    print(find_missing_number(S, n))  # 输出: 0
```
