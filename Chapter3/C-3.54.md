序列S包含n个整数，整数范围为[O，4n]，允许有重复值。描述一个有效算法，确定在S中值为k的整数出现次数最多。该算法的运行时间是多少?

### 算法描述

要确定序列 \(S\) 中出现次数最多的整数 \(k\)（即众数），可以采用 **计数数组** 的方法。由于整数范围固定为 \([0, 4n]\)，且序列长度为
\(n\)，我们可以利用值范围 \(O(n)\) 的特性设计一个高效的算法。算法步骤如下：

1. **初始化计数数组**：
    - 创建一个大小为 \(4n + 1\) 的整数数组 `count`，索引从 \(0\) 到 \(4n\)（对应整数值范围）。所有元素初始化为
      \(0\)。此数组用于存储每个整数的出现次数。

2. **遍历序列并计数**：
    - 对于序列 \(S\) 中的每个元素 \(x\)：
        - 由于 \(x\) 的值在 \([0, 4n]\) 范围内，直接使用 \(x\) 作为索引，将 `count[x]` 增加 \(1\)。

3. **找到最大计数的值**：
    - 初始化两个变量：`max_count = 0`（存储最大出现次数）和 `mode = -1`（存储出现次数最多的值，初始为无效值）。
    - 遍历计数数组 `count` 的每个索引 \(i\)（从 \(0\) 到 \(4n\)）：
        - 如果 `count[i] > max_count`，则更新 `max_count = count[i]` 和 `mode = i`。
    - 此步骤结束后，`mode` 即为所求的 \(k\)（如果多个值出现次数相同且最大，则返回索引最小的那个值）。

4. **返回结果**：
    - 输出 `mode` 作为出现次数最多的整数值 \(k\).

### 算法运行时间

- **时间复杂度**：\(O(n)\)。
    - 创建和初始化计数数组需要 \(O(4n + 1) = O(n)\) 时间（因为 \(4n + 1\) 是 \(n\) 的常数倍）。
    - 遍历序列 \(S\) 进行计数需要 \(O(n)\) 时间（每个元素访问一次，操作 \(O(1)\)）。
    - 遍历计数数组找到最大值需要 \(O(4n + 1) = O(n)\) 时间（数组大小为 \(O(n)\)）。
    - 因此，总运行时间为 \(O(n) + O(n) + O(n) = O(n)\)。
- **空间复杂度**：\(O(n)\)，用于存储大小为 \(4n + 1 = O(n)\) 的计数数组。

### 算法优势

- 此算法利用值范围 \(O(n)\) 的特性，使用数组代替哈希表，避免了哈希冲突的开销，实现简单且高效。
- 时间复杂度和空间复杂度均为线性，相对于输入大小 \(n\) 是最优的（因为至少需要扫描整个序列一次）。
- 如果序列中有多个众数，该算法返回索引最小的那个（即值最小的 \(k\)），但问题只要求任意一个出现次数最多的值，因此满足需求。

此算法在给定条件下（值范围 \([0, 4n]\)）是有效的，运行时间 \(O(n)\) 对于大规模数据也适用。