#### 对代码段3-10中给出的函数example4，使用n对其运行时间做大O描述。

#### 代码结构分析：
```python
def example4(S):
    n = len(S)           # O(1) - 获取序列长度
    prefix = 0           # O(1) - 初始化前缀和
    total = 0            # O(1) - 初始化总和
    for j in range(n):   # 循环n次
        prefix += S[j]   # O(1) - 更新前缀和：访问元素 + 加法
        total += prefix  # O(1) - 更新总和：加法操作
    return total         # O(1) - 返回结果
```

#### 时间复杂度证明：

1. **常数操作分析**：
   - 序列长度获取 `len(S)`: O(1)
   - 变量初始化 `prefix=0` 和 `total=0`: O(1)
   - 返回值操作 `return total`: O(1)
   - 常数操作总数：3 × O(1) = O(1)

2. **循环操作分析**：
   - 单次循环包含：
     - 序列元素访问 `S[j]`: O(1)
     - 前缀和更新 `prefix += ...`: O(1)
     - 总和更新 `total += ...`: O(1)
   - 每次循环总时间：3 × O(1) = O(1)

3. **循环执行次数**：
   - 循环执行 `n` 次（序列长度）

4. **总时间复杂度计算**：
   - 循环操作时间：n × O(1) = O(n)
   - 总时间：
     \[
     \text{O(1)} + \text{O(n)} = \text{O(n)}
     \]

5. **大 O 定义验证**：
   - 设单次循环成本为常数 `c`
   - 总成本函数：
     \[
     T(n) = 3c + n \cdot 3c = 3c(1 + n)
     \]
   - 当 \( n \geq 1 \)，有：
     \[
     T(n) \leq 3c(1 + n) \leq 3c(2n) = (6c) \cdot n
     \]
   - 取常数 \( C = 6c > 0 \) 和 \( n_0 = 1 \)，则对所有 \( n \geq n_0 \):
     \[
     T(n) \leq C \cdot n
     \]
     满足 \( O(n) \) 定义

---

#### 时间复杂度结论：
\[
\boxed{O(n)}
\]

> **算法说明**：
> 1. **功能**：计算序列前缀和的总和  
>    - 示例：S = [1,2,3]  
>      prefix = [1, 1+2=3, 1+2+3=6]  
>      total = 1 + 3 + 6 = 10
> 
> 2. **空间复杂度**：O(1)（仅使用固定数量的变量）
> 
> 3. **优化亮点**：  
>    相比`example3`的O(n²)实现：
>    - 消除嵌套循环  
>    - 利用状态变量`prefix`避免重复计算  
>    - 时间复杂度从二次降至线性（O(n²) → O(n)）
> 
> 4. **计算效率**：
>    | 输入规模 (n) | 操作次数 (T(n)) |
>    |------------|-----------------|
>    | 10         | ≈ 30            |
>    | 100        | ≈ 300           |
>    | 1000       | ≈ 3000          |
>    | n          | 3(1 + n)        |
> 
> 5. **应用场景**：  
>    需要计算所有前缀和累加值的问题
