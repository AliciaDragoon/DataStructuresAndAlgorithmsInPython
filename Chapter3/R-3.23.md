#### 对代码段3-10中给出的函数example1，使用n对其运行时间做大O描述。

#### 代码结构分析：

```python
def example1(S):
    n = len(S)  # O(1) - 常数时间操作
    total = 0  # O(1) - 常数时间操作
    for j in range(n):  # 循环执行 n 次
        total += S[j]  # O(1) - 每次循环的常数时间操作
    return total  # O(1) - 常数时间操作
```

#### 时间复杂度分解：

1. **常数时间操作**：
    - 获取序列长度 `len(S)`
    - 变量初始化 `total = 0`
    - 返回值操作 `return total`  
      总成本：3 × O(1) = O(1)

2. **循环操作**：
    - 循环执行次数：`n`（序列长度）
    - 每次循环包含：索引访问 `S[j]` 和加法操作 `total +=`  
      总成本：n × O(1) = O(n)

#### 总时间复杂度：

O(1) + O(n) = O(n) （常数项在渐近分析中被忽略）

---

#### 大 O 描述：

\[
\boxed{O(n)}
\]

> **说明**：函数执行时间与输入序列长度 `n` 呈**线性关系**。当输入规模增加时：
> - 时间复杂度随 `n` 线性增长
> - 最佳/最坏/平均情况时间复杂度均为 O(n)
> - 这是典型的顺序求和算法时间复杂度特征
> - 