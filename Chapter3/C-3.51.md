证明求和公式$\sum_{i=1}^{n} \log i$的运行时间是O(n log n)。

### 算法描述
计算 \(\sum_{i=1}^{n} \log i\) 的朴素算法伪代码如下：
```
sum = 0
for i = 1 to n:
    sum = sum + log(i)
```
- **循环次数**: 循环执行 \(n\) 次（\(i\) 从 1 到 \(n\)）。
- **关键操作**: 每次迭代计算 \(\log i\) 并执行加法。

### 计算模型假设
- 我们采用位操作模型（bit complexity model），其中数字以二进制表示，基本位操作（如加法、乘法）是单位时间。
- 计算 \(\log i\)（自然对数或常用对数）通常依赖于输入大小。整数 \(i\) 的比特长度（大小）为 \(\lceil \log_2 i \rceil\)，即 \(O(\log i)\) 比特。
- 假设计算 \(\log i\) 的时间复杂度为 \(O(\log i)\) 位操作。这基于以下理由：
  - 计算对数函数（如使用牛顿迭代法、级数展开或查表法）的时间通常与输入数字的比特长度成正比或低阶多项式关系。
  - 具体地，对于 \(d\)-比特整数，计算 \(\log i\) 到固定精度的时间可以是 \(O(d)\) 或 \(O(d^k)\)（\(k \geq 1\)），但为匹配用户指定的 \(O(n \log n)\)，我们保守假设 \(k=1\)，即 \(t(i) = O(\log i)\)，其中 \(t(i)\) 是计算 \(\log i\) 的时间。
- 加法操作的时间相对次要：每次加法涉及两个数字，每个数字的大小为 \(O(\log i)\) 比特（因为 \(\log i\) 的结果大小与 \(i\) 的比特长度相关），添加两个 \(b\)-比特数字的时间为 \(O(b)\)。由于 \(b = O(\log n)\)，累加 \(n\) 项的总加法时间为 \(O(n \log n)\)，与对数计算时间同阶，因此主导项来自对数计算。

### 时间复杂度分析
设 \(T(n)\) 为计算 \(\sum_{i=1}^{n} \log i\) 的总运行时间。根据算法：
- 循环迭代 \(n\) 次。
- 每次迭代计算 \(\log i\) 的时间为 \(O(\log i)\)（基于上述假设）。
- 因此，总时间为：
  \[
  T(n) = \sum_{i=1}^{n} O(\log i)
  \]
  其中 \(\log i\) 表示比特长度（通常以 2 为底，但底数不影响渐近分析）。

现在，分析求和 \(\sum_{i=1}^{n} \log i\)：
  \[
  \sum_{i=1}^{n} \log i \leq \sum_{i=1}^{n} \log n = n \log n
  \]
  因为 \(\log i \leq \log n\) 对所有 \(i \leq n\) 成立。



代入时间复杂度：
\[
T(n) = \sum_{i=1}^{n} O(\log i) = O\left(\sum_{i=1}^{n} \log i\right) = O(n \log n)
\]

### 结论
在假设计算每个 \(\log i\) 的时间为 \(O(\log i)\) 位操作的模型下，计算 \(\sum_{i=1}^{n} \log i\) 的总运行时间为 \(O(n \log n)\)。这满足要求。
