在计算机网络中，通信安全是极其重要的，许多网络协议实现安全的一种策略便是加密信息。确保信息在网络中安全传输的典型加密方案基于这样一个事实：
没有已知的有效算法来分解大的整数。因此，若使用一个大的素数p表示秘密信息，我们就可以在网络中传输数字r=p·q，这里q为另一个大的素数，且q>p，用于作为密钥。
假如窃听者在网络中获取到传输数字r，但若要找出秘密信息p，则必须分解r。
使用分解法找信息时，若不知道密钥q，则非常困难。为了搞清楚原因，先来考虑如下天真的分解算法：
```python
for p in range(2,r):
    if r % p== 0:
        return 'The secret message is p!'
```
1) 假设窃听者采用上述算法，并拥有一台计算机，能够在1ms（1s的百万分之一）时间内，对两个整数做一次除法，其中每个整数都超过100位。
若传输信息r有100位，估计在最坏情况下解读信息p需要多少时间。
2) 上述算法的最坏时间复杂度是什么？因为算法输入的仅仅是一个大的数字r，假设输入大小n表示存储r所需要的字节位数，即n=⌈($\log_{2}$ r)/8⌉+1，
且每次除法运行时间为O(n)。


#### 1) 估计在最坏情况下解读信息 \(p\) 所需的时间
Bob 传输的数字 \(r\) 有 100 位（十进制位），即 \(r\) 的范围为 \(10^{99}\) 到 \(10^{100} - 1\)。窃听者使用天真分解算法，从 \(p = 2\) 开始依次测试每个整数，直到找到能整除 \(r\) 的因子 \(p\)。算法在找到因子后立即停止。

- 在最坏情况下，秘密信息 \(p\) 接近 \(\sqrt{r}\)。因为 \(r = p \times q\) 且 \(q > p\)，当 \(p\) 和 \(q\) 相近时，\(p\) 最大，此时算法需要测试的迭代次数最多。
- 对于 100 位的 \(r\)，有 \(\sqrt{r} \approx 10^{50}\)（因为 \((10^{50})^2 = 10^{100}\))。
- 因此，最坏情况下迭代次数约为 \(10^{50}\) 次。

计算机每次除法操作耗时 1 毫秒（即 \(10^{-3}\) 秒）：
- 总时间 \(= 10^{50} \times 10^{-3} = 10^{47}\) 秒。

为便于理解，将秒转换为年：
- 1 年 \(\approx 365.25 \times 24 \times 3600 = 31,557,600\) 秒 \(\approx 3.15576 \times 10^7\) 秒。
- 年数 \(= \frac{10^{47}}{3.15576 \times 10^7} \approx 3.168 \times 10^{39}\) 年。

此时间远超过宇宙年龄（约 \(1.38 \times 10^{10}\) 年），表明在实践上不可行。

**估计时间：** 约 \(3.17 \times 10^{39}\) 年（或 \(10^{47}\) 秒）。

#### 2) 算法的最坏时间复杂度
输入大小 \(n\) 定义为存储 \(r\) 所需的字节数，即 \(n = \lceil (\log_2 r) / 8 \rceil + 1\)。算法的最坏情况是迭代次数最大时，即当 \(p \approx \sqrt{r}\) 时，迭代次数为 \(O(\sqrt{r})\)。每次迭代执行一次除法操作，运行时间为 \(O(n)\)。

- 由 \(n\) 的定义，对于大 \(r\)，有 \(\log_2 r \approx 8n\)（因为 \(n \approx (\log_2 r)/8\))。
- 因此，\(r \approx 2^{8n}\)，且 \(\sqrt{r} = r^{1/2} \approx (2^{8n})^{1/2} = 2^{4n}\)。
- 迭代次数为 \(O(2^{4n})\)。
- 每次除法耗时 \(O(n)\)，故总时间复杂度为 \(O(n \times 2^{4n})\)。

此时间复杂度是指数级的，因为 \(2^{4n} = 16^n\)，故 \(O(n \times 16^n)\)。

**最坏时间复杂度：** \(O(n \times 2^{4n})\)（或等价于 \(O(n \times 16^n)\)）。
